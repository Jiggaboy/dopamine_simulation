# -*- coding: utf-8 -*-
"""model.ipynb

Automatically generated by Colaboratory.

Original file is located at
        https://colab.research.google.com/drive/1KAmOuq4cxC-ONDuJUq3jNrAelhTmtT8R
"""

# W: connectivity matrix

import numpy as np
import matplotlib.pyplot as plt
import matplotlib
from matplotlib.animation import FuncAnimation
from matplotlib import animation, rc
import time
import random
from enum import Enum
import sklearn.metrics.pairwise
import scipy.spatial.distance
from scipy.integrate import odeint
from sklearn.neighbors import DistanceMetric
from matplotlib.cm import ScalarMappable

import configuration as CF
from custom_class.neurontype import NeuronType

from custom_class.circle import Circle
from custom_class.population import Population
import custom_class.pickler as PIC




#%% Intialisation

# neurons
NE = CF.NE
NI =CF.NI
N = NE + NI

# The areas of slow diffusive feedback
# Look at code cell further down to visualize
c1 = Circle((200.0, 200.0), 50.0)
c2 = Circle((100.0, 100.0), 50.0)
c3 = Circle((75.0, 225.0), 50.0)
diffusion_areas = [c1, c2, c3]

d1 = Circle((30.0, 15.0), 5.0)
diffusion_areas = [d1]

#Time step (in ms)
h = 1 # ms

# Duration of the simulation (in ms)
max_time = 1000. # ms

# time constants of the neurons (in ms)
tau = 20.

# Time axis
t = np.arange(0, max_time, h)

# Initialize the variable
rate = np.zeros((N, len(t)))
# rate[:, 0] = R

ext_in_mean = 4
input_std = 4

# use constant seed for random operations
USE_CONSTANT_SEED = True

PRELOAD_POPULATION = False
SAVE_POPULATION = True                        # only if not preloaded

def set_up_population():

    global W, neuron_coordinate

    if USE_CONSTANT_SEED:
        random.seed(0)

    if PRELOAD_POPULATION:
        neuron_population = Population.load(CF.SPACE_WIDTH)
    else:
        neuron_population = Population(NE, NI, grid_size=(CF.SPACE_HEIGHT, CF.SPACE_WIDTH))

    neuron_coordinate = neuron_population.coordinates
    W = neuron_population.connectivity_matrix

    if SAVE_POPULATION and not PRELOAD_POPULATION:
        neuron_population.save(CF.SPACE_WIDTH)

    return neuron_population

# Neuron transfer function
def sigmoid(x:float, factor:float=1.0, x0:float=0.0, steepness:float=1.0)->float:
    return factor / (1.0 + np.exp(steepness*(x0 - x)))


def transfer_function(input_:float)->float:
    return sigmoid(input_,  x0=10, steepness=10)


def simulate(neural_population:Population, taxis:np.ndarray, **params):
    dopamine_enhancer = params.get("use_slow_diffusion")
    rate = np.zeros((N, len(taxis)))
    for i in range(len(taxis)-1):
        # external_input = np.abs(np.random.normal(ext_in_mean, input_std, size=(N)))
        external_input = np.random.normal(ext_in_mean, input_std, size=(N))
        current_rate = rate[:, i]
        r_dot = neural_population.connectivity_matrix @ current_rate + external_input
        r_dot[r_dot > 200] = 200
        r_dot[r_dot < -1000] = -1000
        if i % 250 == 0:
            print(f"{i}: {r_dot.min()} / {r_dot.max()}")
        r_dot = transfer_function(r_dot)
        rate[:, i+1] = current_rate + (- current_rate + r_dot) / tau
        if dopamine_enhancer:
            neural_population.connectivity_matrix = update_synaptic_weights(rate, i, neural_population, dopamineAreasOnly=True)
    return rate


def update_synaptic_weights(rate:np.ndarray, t:int, population:Population, excOnly:bool=True, dopamineAreasOnly:bool=False)->np.ndarray:
    INTERVAL = 50
    ETA = 1
    conn_matrix = population.connectivity_matrix
    if t-INTERVAL >= 0 and t % INTERVAL == 0:
        W_temp = conn_matrix.copy()
        if excOnly:
            W_temp[W_temp<0] = 0
            W_temp[W_temp>0] = 1

        if dopamineAreasOnly:
            for area in diffusion_areas:
                for neuron in range(len(population.exc_neurons)):
                    if  population.grid.get_distance(area.pos, population.coordinates[neuron]) > area.radius:
                        W_temp[:, neuron] = 0.

        correlation = np.corrcoef(rate[:, t-INTERVAL: t])
        # if True: # only pos. correlation
        #     correlation[correlation < 0] = 0
        conn_matrix = conn_matrix + ETA * W_temp * correlation
        # print(t, conn_matrix)
        # conn_matrix = conn_matrix + conn_matrix * np.abs(correlation)
    return conn_matrix


def animate_firing_rates(rate:np.ndarray, coordinates:np.ndarray, maxNeurons:int=1):
    FIG_NAME = "firing_rate_animation"
    fig = plt.figure(FIG_NAME)
    norm = matplotlib.colors.Normalize(vmin=0, vmax=rate[:, 100:].max())
    scat = plt.scatter(*coordinates[:maxNeurons].T, c=rate[:maxNeurons, 1], cmap=plt.cm.rainbow, norm=norm)
    plt.colorbar(scat)
    def animate(i):
        plt.figure(FIG_NAME)
        scat.set_color(scat.to_rgba(rate[:maxNeurons, i]))
        plt.title(f"Time point: {i}")

    return FuncAnimation(fig, animate, interval=250, frames=range(100, len(t), 10))


#%%% Run Simulation and Plot Firing Rates Over Time With Slow Diffusion

neural_population = set_up_population()
CALC_RATE = True

if CALC_RATE:
    rate = simulate(neural_population, taxis=t, use_slow_diffusion=False)
    # rate = simulate(neural_population, taxis=t, use_slow_diffusion=True)
    PIC.save_rate(rate)
else:
    rate = PIC.load_rate()

neural_population.plot_population()
neural_population.plot_synapses(100, "y")
neural_population.plot_synapses(500, "g")
# neural_population.plot_synapses(N-1, "r")
anim = animate_firing_rates(rate, neural_population.coordinates, NE)

# import custom_class.network_configuration as CN
# CN.plot_shift(*neural_population.coordinates.T, neural_population.shift)

# plt.figure(figsize=(18, 8))
# plt.pcolor(rate[:, ::100])
# colorbar = plt.colorbar()
# plt.xlabel("Time ($10^{-3}$ seconds)")
# plt.ylabel("#neuron")
# plt.title(f"Neurons: {NE}/{NI}; Grid:{CF.SPACE_HEIGHT}x{CF.SPACE_WIDTH}")
# colorbar.set_label('Firing rate')



import sys
sys.exit()

#%%% Run Simulation and Plot Firing Rates Over Time Without Slow Diffusion

#%%%  Neuron Firing Rates by Time With Slow Diffusion

run_simulation(True)

plt.figure(1)
plt.clf()
plt.figure(figsize=(30,10))
plt.plot(t,rate[10:120,:].T)
plt.xlim((650,700))

"""## Print Correlations over time """

set_up_population()
use_slow_diffusion =    True

rate_tmp = np.zeros((N,1))
ed_corr = [-1.0, -0.8, -0.6, -0.4, -0.2, 0.0, 0.2, 0.4, 0.6, 0.8, 1.0]

nn = -1
corr_hist = np.zeros((7000,len(ed_corr)-1))
corr_time = np.zeros(7000)

z = np.zeros((10, 30))

for ii in range(0, len(t)-1):
    # Euler's method
    noise_input = np.random.normal(ext_in_mean, input_std, (N, 1))
    rate_tmp[:, 0] = rate [:, ii]
    dx_dt = transfer_function(W @ rate_tmp + noise_input)

    rate_new = rate_tmp + (- rate_tmp + dx_dt) / tau
    rate[:,ii+1] = rate_new.flatten()

    # Every 100:th iteration, update W with slow diffusive feedback
    if 4000 < ii < 7000:
        if (ii % 100 == 99):
            nn=nn+1
            #print(nn)
            corr_time[nn] = ii
            # Take the 100 most previous (in time) firing rates to calculate correlation
            rate_corr = np.corrcoef(rate[:,ii-99:ii])
            hh,edhh = np.histogram(np.reshape(rate_corr,(1,N**2)),ed_corr)
            corr_hist[nn,:] = hh
            #print(hh)
            #if (use_slow_diffusion):
            #    slow_diffusive_feedback(rate_corr)
            z[:, nn] =    hh


plt.figure(figsize=(7,5))
plt.pcolormesh(t[4001:7000:100], ed_corr, z)
plt.xlabel("Time (ms)")
plt.ylabel("Correlation")
colorbar = plt.colorbar()
colorbar.set_label('Neuron-pairs ')

"""## Slow Diffusive Feeback Areas
Plots the areas where the slow diffusive feedback affects
"""

theta = np.linspace(0, 2*np.pi, 100)
fig, ax = plt.subplots(1)

for i in range(len(diffusion_areas)):
    r = diffusion_areas[i].radius

    x1 = r*np.cos(theta) + diffusion_areas[i].x1
    x2 = r*np.sin(theta) + diffusion_areas[i].x2

    ax.plot(x1, x2, color="red")

ax.scatter(x1_cordinates, x2_cordinates)

"""## Animation of network"""

#time = np.arange(0, 5, 0.001)
#print(time)

#r = odeint(simulate, R, time, args=(W,))

#matplotlib.rcParams['animation.embed_limit'] = 2**128

fig, ax = plt.subplots()
# scat = ax.scatter(x1_cordinates, x2_cordinates, c=rate[:, 0], cmap=plt.cm.rainbow,  norm=matplotlib.colors.Normalize(vmin=0, vmax=rate.max()))
scat = ax.scatter(*neural_population.coordinates.T, c=rate[:, 0], cmap=plt.cm.rainbow,  norm=matplotlib.colors.Normalize(vmin=0, vmax=rate.max()))
fig.colorbar(scat, ax=ax)

def animate(i):
    scat.set_color(scat.to_rgba(rate[:, i]))
FuncAnimation(fig, animate, interval=10, frames=len(t[:100]))
# anim = FuncAnimation(fig, animate, interval=100, frames=len(t[900:1500])-1)

rc('animation', html='jshtml')
anim



"""## Snapshots from the Animation"""

fig, axes = plt.subplots(3,3, figsize=(20,15))
print(rate.shape)

#fig.figure(figsize=(20,10))

axes[0,0].scatter(x1_cordinates, x2_cordinates, c=rate[:, 0],cmap=plt.cm.rainbow, norm=matplotlib.colors.Normalize(vmin=0, vmax=rate.max()))
axes[0,0].set_title("Time 0 ms")

axes[0,1].scatter(x1_cordinates, x2_cordinates, c=rate[:, 10],cmap=plt.cm.rainbow, norm=matplotlib.colors.Normalize(vmin=0, vmax=rate.max()))
axes[0,1].set_title("Time 1 ms")

axes[0,2].scatter(x1_cordinates, x2_cordinates, c=rate[:, 20],cmap=plt.cm.rainbow, norm=matplotlib.colors.Normalize(vmin=0, vmax=rate.max()))
axes[0,2].set_title("Time 2 ms")

axes[1,0].scatter(x1_cordinates, x2_cordinates, c=rate[:, 30],cmap=plt.cm.rainbow, norm=matplotlib.colors.Normalize(vmin=0, vmax=rate.max()))
axes[1,0].set_title("Time 3 ms")

axes[1,1].scatter(x1_cordinates, x2_cordinates, c=rate[:, 40],cmap=plt.cm.rainbow, norm=matplotlib.colors.Normalize(vmin=0, vmax=rate.max()))
axes[1,1].set_title("Time 4 ms")

axes[1,2].scatter(x1_cordinates, x2_cordinates, c=rate[:, 50],cmap=plt.cm.rainbow, norm=matplotlib.colors.Normalize(vmin=0, vmax=rate.max()))
axes[1,2].set_title("Time 5 ms")

axes[2,0].scatter(x1_cordinates, x2_cordinates, c=rate[:, 60],cmap=plt.cm.rainbow, norm=matplotlib.colors.Normalize(vmin=0, vmax=rate.max()))
axes[2,0].set_title("Time 6 ms")

axes[2,1].scatter(x1_cordinates, x2_cordinates, c=rate[:, 70],cmap=plt.cm.rainbow, norm=matplotlib.colors.Normalize(vmin=0, vmax=rate.max()))
axes[2,1].set_title("Time 7 ms")

axes[2,2].scatter(x1_cordinates, x2_cordinates, c=rate[:, 80],cmap=plt.cm.rainbow, norm=matplotlib.colors.Normalize(vmin=0, vmax=rate.max()))
axes[2,2].set_title("Time 8 ms")


cmap = plt.get_cmap("rainbow")
norm = plt.Normalize(rate.min(), rate.max())
sm =    ScalarMappable(norm=norm, cmap=cmap)
sm.set_array([])
cbar = fig.colorbar(sm, ax=axes[:,2])
cbar.ax.set_title("Firing rate")

plt.show()

plt.plot(np.mean(W,1),np.std(rate,1),'.')

"""## Plot sigmoid function input and output"""

fig, ax = plt.subplots(nrows=1, ncols=3, figsize=(15,5))

for tick in range(time.shape[0]):
    x_plot = []
    y_plot = []

    for i in range(W.shape[0]):
        x_plot.append(W[i] @ r[tick])
        y_plot.append(transfer_function(W[i] @ r[tick]))

    if (tick == 0):
        ax[0].plot(x_plot, y_plot, "ro")
    elif (tick == 30):
        ax[1].plot(x_plot, y_plot, "ro")
    elif (tick == 60):
        ax[2].plot(x_plot, y_plot, "ro")

plt.show()

"""

## Plot positions of inibitory and excititory neurons on the toroid
"""

colors = []
for i in range(neuron_coordinate.shape[0]):
    if (neuron_polarity[i] == NeuronType.EXCITATORY):
        colors.append("blue")
    else:
        colors.append("red")

plt.scatter(x1_cordinates, x2_cordinates, c=colors)

"""## Plot connection probabilities"""

colors = []
for i in range(neuron_coordinate.shape[0]):
    if (neuron_polarity[i] == NeuronType.EXCITATORY):
        colors.append("yellow")
    else:
        colors.append("red")
z = []

x1_cordinates = [x[0] for x in neuron_coordinate]
x2_cordinates = [x[1] for x in neuron_coordinate]

x1 = np.linspace(0, 299, 300)
x2 = np.linspace(0, 299, 300)

z = np.zeros((CF.SPACE_HEIGHT, CF.SPACE_WIDTH))

for neuron_index in range(neuron_coordinate.shape[0]):
    for i in range(CF.SPACE_HEIGHT):
        for j in range(CF.SPACE_WIDTH):
            cor = np.array([i, j])
            if (neuron_polarity[neuron_index] == NeuronType.EXCITATORY):
                z[j, i] += gaussian(neuron_coordinate[neuron_index], cor, SIGMA_EXC)
            else:
                z[j, i] += gaussian(neuron_coordinate[neuron_index], cor, SIGMA_INH)

plt.contourf(x1, x2, z,cmap="Blues")
plt.colorbar()
plt.scatter(x1_cordinates, x2_cordinates, c=colors)

"""## Plot Connection Matrix"""

exh_sum = 0
inh_sum = 0

exh = np.zeros(N)
inh = np.zeros(N)
for i in range(N):
    for j in range(N):
        if (W[i, j] == 1.0):
            exh[i] += 1.0
            exh_sum += 1
        elif (W[i, j] == -5.0):
            inh[i] += 1.0
            inh_sum += 1


average_exh = np.sum(exh) / N
average_inh = np.sum(inh) / N

print(average_exh / (average_exh + average_inh))
print(average_inh / (average_exh + average_inh))


plt.pcolor(W)
plt.colorbar()
plt.clim(-1, 1)

avg_rate = np.mean(rate[:,100:],1)
np.shape(avg_rate)
rate_corr = np.corrcoef(rate[:,100:])
np.shape(rate_corr)


W_copy = np.copy(W)

W_exc = W_copy[:,0:NE]
we_con = W_exc
we_con[we_con>0.] = 1 # 1 if there is a connection, 0 otherwise

rate_corr = np.corrcoef(rate[:,0:100])

del_w = we_con * rate_corr[:,0:NE] # keep the correlation only for connected paira

W_new = np.copy(W)
W_new[:,0:NE] = W[:,0:NE] + del_w

plt.figure(figsize=(30,10))
plt.pcolor(W_new-W)


plt.colorbar()

"""## Simulation with Correlations"""

def simulation_with_correlation(use_slow_diffusive_feedback):
    rate_tmp = np.zeros((N,1))
    nn = -1

    global corr_hist
    global corr_time
    global rate_corr

    corr_hist = np.zeros((10, N**2))
    corr_time = np.zeros(40)

    z = np.zeros(10)

    for ii in range(0, len(t)-1):
        # Euler's method
        noise_input = np.random.normal(ext_in_mean, input_std,(N,1))
        rate_tmp[:,0] = rate [:,ii]
        dx_dt = transfer_function(W @ rate_tmp + noise_input)

        rate_new = rate_tmp + (- rate_tmp + dx_dt)/tau
        rate[:,ii+1] = rate_new.flatten()

        if 2000 < ii < 7000:
            if (ii % 500 == 499):
                nn=nn+1

                neurons_average_rate = np.mean (rate[:, ii-500: ii], axis=1)
                average_firing_rate = np.mean(neurons_average_rate)
                rate_corr = np.corrcoef(rate[:,ii-500:ii])

                corr_time[nn] = ii
                rate_corr = np.corrcoef(rate[:,ii-99:ii])
                corr_hist[nn,:] = np.reshape(rate_corr,(1,N**2))

                if (use_slow_diffusive_feedback):
                    slow_diffusive_feedback(rate_corr)

                z[nn] =    average_firing_rate

    return z

set_up_population()

rate_tmp = np.zeros((N,1))
nn = -1

z1 = simulation_with_correlation(False)

set_up_population()

rate_tmp = np.zeros((N,1))
nn = -1

z2 = simulation_with_correlation(True)

z = np.stack((z1,z2))

plt.figure(figsize=(7,5))
plt.pcolormesh(np.array([200, 250, 300, 350, 400, 450, 500, 550, 600, 650, 700]), np.array([0,1,2]), z)
plt.xlabel("Time (ms)")
plt.ylabel("No Diffusive Feeback                         Diffusive Feedback")
plt.yticks([])
colorbar = plt.colorbar()
colorbar.set_label('Average Neuron Firing-rate')

"""## Histogram Plots"""

set_up_population()

rate_tmp = np.zeros((N,1))
ed_corr = [-1.0, -0.8, -0.6, -0.4, -0.2, 0.0, 0.2, 0.4, 0.6, 0.8, 1.0]

simulation_with_correlation(True)

plt.figure(figsize=(10,8))
plt.hist(corr_hist.T, bins=ed_corr, stacked=False)
plt.legend(['200-250 ms', '250-300 ms', '300-350 ms,', '350-400 ms','400-450 ms','450-500 ms','500-550 ms','550-600 ms','600-650 ms','650-700 ms'])
plt.xlabel("Correlation")
plt.ylabel("#neuron-pairs")
plt.xticks([-1.0, -0.8, -0.6, -0.4, -0.2, 0.0, 0.2, 0.4, 0.6, 0.8, 1.0], rotation=45, rotation_mode="anchor", ha="right")

"""## Mean Coorelation of all Neurons over Timesteps """

simulation_with_correlation(True)

dist = DistanceMetric.get_metric('euclidean')
neuron_coordinate[1:3]
neuron_loc = np.zeros((NE,2))
for ii in range(NE):
    neuron_loc[ii,:] = neuron_coordinate[ii]
dd = dist.pairwise(neuron_loc)

dd_flatten = dd.flatten()
rate_corr_NE_flatten = rate_corr[0:NE,0:NE].flatten()

dd_rate_corr = np.stack((dd_flatten, rate_corr_NE_flatten))

intervals = np.arange(0.0, 400.0 + 4, 4)
distance_mid = np.arange(2.0, 398.0 + 4, 4)


filtered = []

for i in range(1, intervals.shape[0]):
    tmp = []
    for j in range(dd_rate_corr.shape[1]):
        if (dd_rate_corr[0, j] > intervals[i - 1] and dd_rate_corr[0, j] < intervals[i]):
            tmp.append(dd_rate_corr[1, j])

    filtered.append(np.mean(tmp))


print(filtered)
print(rate_corr[0:NE,0:NE].shape)
plt.plot(distance_mid, filtered,'.')
