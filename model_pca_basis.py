# -*- coding: utf-8 -*-
"""model.ipynb

Automatically generated by Colaboratory.

Original file is located at
        https://colab.research.google.com/drive/1KAmOuq4cxC-ONDuJUq3jNrAelhTmtT8R
"""

# W: connectivity matrix

import numpy as np
import matplotlib.pyplot as plt
import random

import configuration as CF


from custom_class.population import Population
import custom_class.pickler as PIC


import animation.activity as ANIM

import dopamine as DOP




#%% Intialisation

# neurons
NE = CF.NE
NI =CF.NI
N = NE + NI

#Time step (in ms)
h = 1 # ms

# Duration of the simulation (in ms)
max_time = 10800. # ms

# time constants of the neurons (in ms)
tau = 10.

ext_in_mean = 4
input_std = 4


PATCH_SIZE = 4
THRESHOLD = 0.2
ETA = 1
INTERVAL = 50
DOP_DURATION = 25

# Time axis
t = np.arange(0, max_time + CF.WARMUP, h)
# Initialize the variable
rate = np.zeros((N, len(t)))

# use constant seed for random operations
USE_CONSTANT_SEED = True

PRELOAD_POPULATION = True
SAVE_POPULATION = True                        # only if not preloaded

def set_up_population():

    if USE_CONSTANT_SEED:
        random.seed(0)

    if PRELOAD_POPULATION:
        neuron_population = Population.load(CF.SPACE_WIDTH)
    else:
        neuron_population = Population(NE, NI, grid_size=(CF.SPACE_HEIGHT, CF.SPACE_WIDTH))

    if SAVE_POPULATION and not PRELOAD_POPULATION:
        neuron_population.save(CF.SPACE_WIDTH)

    return neuron_population

# Neuron transfer function
def sigmoid(x:float, x0:float=0.0, steepness:float=1.0)->float:
    return 1 / (1.0 + np.exp(steepness*(x0 - x)))


def transfer_function(input_:float)->float:
    return sigmoid(input_,  x0=10, steepness=10)


def simulate(neural_population:Population, taxis:np.ndarray, **params):
    three_fac_learning = params.get("dopamine_patches")
    rate = np.zeros((N, len(taxis)))
    for t in range(len(taxis)-1):
        external_input = np.random.normal(ext_in_mean, input_std, size=(N))
        current_rate = rate[:, t]
        r_dot = neural_population.connectivity_matrix @ current_rate + external_input  # expensive!!!
        r_dot[r_dot > 2000] = 2000
        r_dot[r_dot < -1000] = -1000
        if t % 450 == 0:
            print(f"{t}: {r_dot.min()} / {r_dot.max()}")
        r_dot = transfer_function(r_dot)
        rate[:, t+1] = current_rate + (- current_rate + r_dot) / tau

        if three_fac_learning and t > CF.WARMUP:
            if t % INTERVAL == 0:
                # get a dopamine patch
                patch = DOP.perlin_patch(neural_population.grid.width, size=PATCH_SIZE)
                # get active neurons at current timestep t
                exc_neurons = len(neural_population.exc_neurons)
                recently_active_neurons = rate[:exc_neurons, t-DOP_DURATION:t] >= THRESHOLD
                active_neurons = np.any(recently_active_neurons, axis=1)
                W = neural_population.connectivity_matrix
                strengthen_synapses = patch & active_neurons
                strengthen_synapses = np.argwhere(strengthen_synapses).flatten()
                W[strengthen_synapses, :] = W[strengthen_synapses, :] * (1 + ETA)
                # W[:, strengthen_synapses] = W[:, strengthen_synapses] * (1 + ETA) # update out-degrees
    return rate



#%%% Run Simulation and Plot Firing Rates Over Time With Slow Diffusion

neural_population = set_up_population()
CALC_RATE = True
CALC_RATE = False

if CALC_RATE:
    # rate = simulate(neural_population, taxis=t, hebbian_plasticity=False)
    rate = simulate(neural_population, taxis=t, dopamine_patches=True)
    # rate = simulate(neural_population, taxis=t, dopamine_patches=False)
    # rate = simulate(neural_population, taxis=t, hebbian_plasticity=True)
    PIC.save_rate(rate)
else:
    rate = PIC.load_rate()

# neural_population.plot_population()
# neural_population.plot_synapses(800, "y")
# neural_population.plot_synapses(2040, "g")
# neural_population.plot_synapses(N-1, "r")
anim = ANIM.animate_firing_rates(rate, neural_population.coordinates, NE, start=8500, step=60)

# import custom_class.network_configuration as CN
# CN.plot_shift(*neural_population.coordinates.T, neural_population.shift)

# plt.figure(figsize=(18, 8))
# plt.pcolor(rate[:, ::100])
# colorbar = plt.colorbar()
# plt.xlabel("Time ($10^{-3}$ seconds)")
# plt.ylabel("#neuron")
# plt.title(f"Neurons: {NE}/{NI}; Grid:{CF.SPACE_HEIGHT}x{CF.SPACE_WIDTH}")
# colorbar.set_label('Firing rate')
